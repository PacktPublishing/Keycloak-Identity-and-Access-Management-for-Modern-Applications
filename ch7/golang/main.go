/*
This is an example about how to use a public client written in Golang to authenticate using Keycloak.
This example is only for demonstration purposes
*/
package main

import (
	"encoding/json"
	"errors"
	"io"
	"log"
	"net/http"
	"strings"
	"time"

	oidc "github.com/coreos/go-oidc"
	"github.com/google/uuid"
	"golang.org/x/net/context"
	"golang.org/x/oauth2"
)

const KEYCLOAK_REALM_URL = "http://localhost:8180/realms/myrealm"

var oidcProvider oidc.Provider
var oidcConfig oidc.Config
var oauth2Config oauth2.Config
var idTokenVerifier oidc.IDTokenVerifier

func init() {
	oidcProvider = *createOidcProvider(context.Background())
	oidcConfig, oauth2Config = createConfig(oidcProvider)
	idTokenVerifier = *oidcProvider.Verifier(&oidcConfig)
}

func createOidcProvider(ctx context.Context) *oidc.Provider {
	provider, err := oidc.NewProvider(ctx, KEYCLOAK_REALM_URL)

	if err != nil {
		log.Fatal("Failed to fetch discovery document: ", err)
	}

	return provider
}

func createConfig(provider oidc.Provider) (oidc.Config, oauth2.Config) {
	oidcConfig := &oidc.Config{
		ClientID: "mywebapp",
	}

	config := oauth2.Config{
		ClientID:     oidcConfig.ClientID,
		ClientSecret: "CLIENT_SECRET", // change CLIENT_SECRET with the secret generated by Keycloak for the mywebapp client. This option is a string.
		Endpoint:     provider.Endpoint(),
		RedirectURL:  "http://localhost:8080/auth/callback",
		Scopes:       []string{oidc.ScopeOpenID, "profile", "email"},
	}

	return *oidcConfig, config
}

func main() {
	http.HandleFunc("/", redirectHandler)
	http.HandleFunc("/auth/callback", callbackHandler)

	log.Printf("To authenticate go to http://%s/", "localhost:8080")
	log.Fatal(http.ListenAndServe("localhost:8080", nil))
}

func redirectHandler(resp http.ResponseWriter, req *http.Request) {
	_, err := req.Cookie("p_sessionid")

	if err != nil {
		// not authenticated, redirect to Keycloak
		state := uuid.New().String()
		setStateCookie(resp, state)
		http.Redirect(resp, req, oauth2Config.AuthCodeURL(state), http.StatusFound)
	} else if strings.Contains(req.URL.RequestURI(), "/auth/callback") {
		// authenticated, querying the callback url result in a redirect to the root path
		http.Redirect(resp, req, "http://localhost:8080", http.StatusFound)
	} else {
		// user authenticated, landing page
		io.WriteString(resp, "<html><body>"+
			"You are already authenticated. "+
			"Click <a href='"+KEYCLOAK_REALM_URL+"/protocol/openid-connect/logout?client_id="+oidcConfig.ClientID+"'>here</a> to logout"+
			"</body></html>")
	}
}

func setStateCookie(resp http.ResponseWriter, stateValue string) {
	maxAge := 60
	setCookie("p_state", stateValue, maxAge, resp)
}

func callbackHandler(resp http.ResponseWriter, req *http.Request) {
	err := checkState(req, resp)

	if err != nil {
		redirectHandler(resp, req)
		return
	}

	tokenResponse, err := exchangeCode(req)

	if err != nil {
		http.Error(resp, "Failed to exchange code", http.StatusBadRequest)
		return
	}

	idToken, err := validateIDToken(tokenResponse, req)

	if err != nil {
		http.Error(resp, "Failed to validate id_token", http.StatusUnauthorized)
		return
	}

	handleSuccessfulAuthentication(tokenResponse, *idToken, resp)
}

func setCookie(name string, value string, maxAge int, resp http.ResponseWriter) {
	cookie := http.Cookie{
		Name:     name,
		Value:    value,
		MaxAge:   maxAge,
		Path:     "/",
		HttpOnly: true,
	}

	http.SetCookie(resp, &cookie)
}

func expireCookie(name string, resp http.ResponseWriter) {
	setCookie(name, "", -1, resp)
}

func checkState(req *http.Request, resp http.ResponseWriter) error {
	expireCookie("p_state", resp)

	state, err := req.Cookie("p_state")

	if err != nil {
		log.Println("state cookie check failed")
		return errors.New("state cookie not set")
	}

	if req.URL.Query().Get("state") != state.Value {
		return errors.New("invalid state")
	}

	return nil
}

func exchangeCode(req *http.Request) (*oauth2.Token, error) {
	httpClient := &http.Client{Timeout: 2 * time.Second}
	ctx := context.WithValue(req.Context(), oauth2.HTTPClient, httpClient)

	tokenResponse, err := oauth2Config.Exchange(ctx, req.URL.Query().Get("code"))

	if err != nil {
		return nil, err
	}

	return tokenResponse, nil
}

func validateIDToken(tokenResponse *oauth2.Token, req *http.Request) (*oidc.IDToken, error) {
	rawIDToken, ok := tokenResponse.Extra("id_token").(string)

	if !ok {
		return nil, errors.New("id_token is not in the token response")
	}

	idToken, err := idTokenVerifier.Verify(req.Context(), rawIDToken)

	if err != nil {
		return nil, err
	}

	return idToken, nil
}

func handleSuccessfulAuthentication(tokenResponse *oauth2.Token, idToken oidc.IDToken, resp http.ResponseWriter) {
	// session cookie will keep user authenticated in the application for a max of 60s
	setCookie("p_sessionid", uuid.New().String(), 60, resp)

	payload := struct {
		TokenResponse *oauth2.Token
		IDToken       *json.RawMessage
	}{tokenResponse, new(json.RawMessage)}

	if err := idToken.Claims(&payload.IDToken); err != nil {
		return
	}

	data, err := json.MarshalIndent(&payload, "", "    ")

	if err != nil {
		http.Error(resp, err.Error(), http.StatusInternalServerError)
		return
	}

	resp.Write(data)
}
